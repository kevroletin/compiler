                                  .-----------------.
                                  | Краткая справка |
                                  '-----------------'

Компилятор Pascal
Использование: compiler [опция] имя_файла
Доступные опции:

оптимизация отключена
	-b	вывести вместе дерево разбора и таблицу символов 
	-h	показать это сообщение
	-g	сгенерировать код для 32х битной версии GNU assembler
	-l	вывести поток лексем
	-s	вывести дерево разбора
	-t	вывести таблицу символов

оптимизация включена
	-B	вывести вместе дерево разбора и таблицу символов
	-G	сгенерировать код для 32х битной версии GNU assembler
	-S	вывести дерево разбора
	-T	вывести таблицу символов

                                  .-------------.
                                  | О программе |
                                  '-------------'

Компилятор Pascal(в действитеьности компилятор довольно сильно урезанного подмножества языка Pascal).

Автор: студент 236группы ИМКН ДВФУ Кевролетин В.В.
Руководитель: старший преподаватель кафедры информатики ИМКН ДВФУ Кленин А.С.
Дата сдачи: 1й семестр 2010/2011 учебного года.

От полноценного компилятора данный проект отделяют следующие ограничения:
 -только 2 базовых типа: Real(вещественные числа одинарной точности, 4 байта), Integer(целые числа, 4 байта)
 -нет указателей (передача параметров в процедуры по ссылке все же есть)
 -нет низкоуровневой оптимизации (реализация высокоуровневой оказалась интереснее)
 -вероятнее всего, большое количество ошибок

                                .--------------------.
                                | Компиляция проекта |
                                '--------------------'

Исходный код написан на языке C++ и компилировался при помощи GCC под операционной системой x86_64 GNU/Linux.
В принципе, никаких изменений для 32-х битный версий GNU/Linux потребоваться не должно. К сожалению, c такой
же уверенностью нельзя то же самое сказать про Win32. 

Устройство проекта:
 1. Исходные коды программы: файлы *.h *.cpp. Лежат в корне проекта.
 2. Тесты: пары (входные данные; результат), где входные данные файл TEST_NUM.in, а результат 
TEST_NUM.out, где TEST_NUM - какое либо натуральное число. Тесты разбиты на группы, в зависимости от того, 
какую часть компилятора они тестируют(в действительности это разделение не очень четкое и, скорее, тесты
разделены на группы, в зависимости от того, когда их писал автор), каждая группа тестов помещена в отдельную
напку с именем, начинающемся со слова "test"
 3. Тестирующие скрипты: файлы test.sh. Лежат в каждой папке с тестами. Для запуска используйте командрую 
строку shell или bash, которые найдутся в любом дистрибутиве Unix-подобных систем (для win прийдётся 
искать отдельно. См., к примеру, MinGW или Cygwin). Тестырующий скрипт в корне проекта последовательно
запускает тестирующие скрипты для каждой группы тестов.
 4. Файлы проектов: compiler.cbp - файл проекта для Code::Blocks IDE и Project.ede файл проекта для EDE
(утилита управления проектами, входящяя в состав CEDET - Common Emacs Development Enviroment);
 5. Makefile - автоматически сгенерированный makefile, созданный утилитой EDE. Содержит только одну цель - 
debug.

Для того, чтобы воспользоваться компилятором его нужно сначала.. скомпилировать:
 создание исполняемого файла с отладочной информацией производится, к примеру, так:
  - ~$ make 
  - ~$ g++ -c -g *.cpp && g++ -L. -g *.o -o debug
  - открыть проект в emacs с установленным пакетом CEDET и скомпилировать (M-x ede-compile-project)
  - открыть проект в CODE::Blocks, выбрать цель Debug скомпилировать
 создание исполняемого файла без отладочной информации:
  - ~$ g++ -c *.cpp && g++ -L. *.o -o debug
  - открыть проект в CODE::Blocks, выбрать цель Debug скомпилировать

                                      .--------.
                                      | Запуск |
                                      '--------'

Далее, можно запустить компилятор из командной строки; или запустить тестирущий скрипт, к
примеру, вот так: ~$ sh test.sh (тестирущие скрипты требуют, чтобы тестируемый 
исполняемый файл компилятор назывался "debug" {или debug.exe для win32} и лежал в корне проекта).

Запуск программы из командной строки без ключей, или с ключом -h, приведёт к выводу краткой справки. 

Вся информация, к примеру, поток лексем, дерево разбора, ассемблерный код или информация об ошибках выводятся 
на консоль.
В случае успешного завершения работы, компилятор возвращает код 0.
В случае возникновения ошибки компилятор заканчивает свою работу. Возвращает код 1 и выводит сообщение,
разъясняющую причину возникневения ошибки.

                                      .-----------.
                                      | От автора |
                                      '-----------'

Данный проект полезен восновном в учебных целях и служит примером того, как можно реализовать зачётное задание
для сдачи практической части курса Языки Программирования и Методы Трансляции. Автор считает данный проект
не самым лучшим, но полезным примером (учитывая тот факт, что некоторые части проекта можно рассматривать, как
антипример, то довольно поучительным примером).

Исходный код так же доступен по адресу:
http://github.com/vkevroletin/compiler
